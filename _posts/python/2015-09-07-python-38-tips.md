---
layout: post
title: "38ä¸ªpythonæ•°æ®ç±»å‹å°æŠ€å·§"
description: "38ä¸ªpythonæ•°æ®ç±»å‹å°æŠ€å·§"
category: "python"
tags: [pythonå¥‡æŠ€æ·«å·§]
---

æ‘˜è‡ª[30 Python Language Features and Tricks You May Not Know About](http://sahandsaba.com/thirty-python-language-features-and-tricks-you-may-not-know.html), å…¶ä¸­ä¸€äº›çŸ¥è¯†ç‚¹æˆ‘åŠ äº†é‡Šä¹‰å’Œå‚è€ƒï¼Œenjoy ğŸ˜Š.

![](http://beginman.qiniudn.com/Python-tips-trics-hacks-for-web-application-development.jpg)

# 1.Unpacking

	>>> a, b, c = 1, 2, 3
	>>> a, b, c
	(1, 2, 3)
	>>> a, b, c = [1, 2, 3]
	>>> a, b, c
	(1, 2, 3)
	>>> a, b, c = (2 * i + 1 for i in range(3))
	>>> a, b, c
	(1, 3, 5)
	>>> a, (b, c), d = [1, (2, 3), 4]
	>>> a
	1
	>>> b
	2
	>>> c
	3
	>>> d
	4



# 2.Unpacking for swapping variables

	>>> a, b = 1, 2
	>>> a, b = b, a
	>>> a, b
	(2, 1)

# 3. Extended unpacking (Python 3 only)

	>>> a, *b, c = [1, 2, 3, 4, 5]
	>>> a
	1
	>>> b
	[2, 3, 4]
	>>> c
	5

# 4.Negative indexing

	>>> a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	>>> a[-1]
	10
	>>> a[-3]
	8

# 5.List slices (a[start:end])
	
	>>> a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	>>> a[2:8]
	[2, 3, 4, 5, 6, 7]

# 6.List slices with negative indexing
	
	>>> a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	>>> a[-4:-2]
	[7, 8]

# 7.List slices with step (a[start:end:step])

	>>> a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	>>> a[::2]
	[0, 2, 4, 6, 8, 10]
	>>> a[::3]
	[0, 3, 6, 9]
	>>> a[::-1]
	[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
	>>> a[2:8:2]
	[2, 4, 6]

è¿™é‡Œå°±å‘è§‰å¾ˆå¥‡æ€ªäº†ï¼Œåˆ‡ç‰‡æ“ä½œï¼Œ`a[start:end:step]`, å‚æ•°è§£é‡Šå¦‚ä¸‹ï¼š
- `start`:ç¬¬ä¸€ä¸ªå…ƒç´ å¯¹è±¡ï¼Œæ­£ç´¢å¼•ä½ç½®é»˜è®¤ä¸º0ï¼›è´Ÿç´¢å¼•ä½ç½®é»˜è®¤ä¸º `-len(seq)`
- `end`: æœ€åä¸€ä¸ªå…ƒç´ å¯¹è±¡ï¼Œæ­£ç´¢å¼•ä½ç½®é»˜è®¤ä¸º `len(seq)`ï¼1ï¼›è´Ÿç´¢å¼•ä½ç½®é»˜è®¤ä¸º -1
- `step`ï¼šæ­¥é•¿ï¼Œé»˜è®¤ä¸º1ï¼Œæ­¥é•¿å€¼ä¸èƒ½ä¸º0ã€‚

å¦‚æœç´¢å¼•ä¸ºæ­£ï¼Œåˆ™ä»å·¦è‡³å³å–å€¼ï¼Œå¦‚:

	>>> a[1:5:2]
	[1, 3]
	>>> a[1:5:1]
	[1, 2, 3, 4]
	>>> a[1:5:]
	[1, 2, 3, 4]

å¦‚æœä¸ºè´Ÿï¼Œåˆ™ä»å³å¾€å·¦ï¼Œ

	>>> a[-10:-6:2]
	[1, 3]

å…¶ä¸­ï¼Œä¸‰è€…éƒ½å¯ä»¥çœç•¥ï¼š

	>>> a[::]
	[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	>>> a[1::]
	[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	>>> a[:3:]
	[0, 1, 2]
	>>> a[::1]
	[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	>>> a[::2]
	[0, 2, 4, 6, 8, 10]
	>>> a[-1::]
	[10]
	>>> a[-3::]
	[8, 9, 10]
	>>> a[:-1:]
	[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
	>>> a[:-3:]
	[0, 1, 2, 3, 4, 5, 6, 7]
	>>> a[::-1]
	[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
	>>> 

æ›´è¿‡åˆ‡ç‰‡çš„çŸ¥è¯†å¯å‚è€ƒ:[ç†è§£pythonåºåˆ—ç±»å‹çš„åˆ‡ç‰‡](http://beginman.cn/pythonæŠ€å·§/2015/04/09/python-splice/)


# 8.List slices with negative step

	>>> a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	>>> a[::-1]
	[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
	>>> a[::-2]
	[10, 8, 6, 4, 2, 0]

# 9. List slice assignment

	>>> a = [1,2,3,4,5]
	>>> a[2:3]
	[3]
	>>> a[2:3] = [0, 0]
	>>> a
	[1, 2, 0, 0, 4, 5]
	>>> a[2:3] 
	[0]
	>>> a[2:4]
	[0, 0]
	>>> a[2:4] = [1,2,3]
	>>> a[2:3]
	[1]
	>>> a[2:4] 
	[1, 2]
	>>> a
	[1, 2, 1, 2, 3, 4, 5]

è¿™é‡Œå¯¹åˆ‡ç‰‡è¿›è¡Œèµ‹å€¼ï¼Œå¦‚`a[2:3]`è¿”å›çš„æ˜¯**å¼•ç”¨**ï¼Œæˆ‘ä»¬å¯¹å®ƒèµ‹å€¼ä¼šå½±å“æºåºåˆ—

	>>> a[2:4] = ['a', 'b', 'c', 'd']			# å°†['a', 'b', 'c', 'd']èµ‹å€¼ç»™a[2:4]å¼•ç”¨,æ’å…¥è‡³åŸåºåˆ—aä¸­
	>>> a
	[1, 2, 'a', 'b','c','d' 5]
	
åŒç†ï¼Œä¹Ÿå¯ä»¥åˆ é™¤å®ƒä»¬ï¼š

	>>> a = [1,2,3,4,5]
	>>> a[2:4] = []
	>>> a
	[1, 2, 5]


# 10. Naming slices (slice(start, end, step))

	>>> my = slice(4)
	>>> my
	slice(None, 4, None)
	>>> l = list(range(10))
	>>> l
	[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
	>>> l[my]
	[0, 1, 2, 3]
	>>> slice(5)
	slice(None, 5, None)
	>>> slice(2)
	slice(None, 2, None)
	>>> slice(1)
	slice(None, 1, None)
	>>> slice(-2)
	slice(None, -2, None)
	>>> slice(3, None)
	slice(3, None, None)
	>>> slice(1, 3, None)
	slice(1, 3, None)

`slice(start, end, step)` å†…ç½®å‡½æ•°ï¼Œä¹Ÿå°±æ˜¯åˆ‡ç‰‡çš„åŸç”Ÿã€‚

# 11. Iterating over list index and value pairs (enumerate)

	>>> a = ['Hello', 'world', '!']
	>>> for i, x in enumerate(a):
	...     print '{}: {}'.format(i, x)
	...
	0: Hello
	1: world
	2: !

å¯¹äºåˆ—è¡¨ï¼Œ`enumerate()`è¿”å›ç´¢å¼•å’Œå¯¹åº”çš„å€¼.

# 12. Iterating over dictionary key and value pairs (dict.iteritems)

	>>> m = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
	>>> for k, v in m.iteritems():
	...     print '{}: {}'.format(k, v)
	...
	a: 1
	c: 3
	b: 2
	d: 4

å¯¹äºå­—å…¸,`dict.iteritems()`è¿”å›é”®å€¼å¯¹ã€‚

**Note: use dict.items in Python 3.**

# 13. Zipping and unzipping lists and iterables

	>>> a = [1,2,3]
	>>> b = ['a','b','c']
	>>> zip(a, b)
	[(1, 'a'), (2, 'b'), (3, 'c')]
	>>> s = zip(a, b)
	>>> zip(s)
	[((1, 'a'),), ((2, 'b'),), ((3, 'c'),)]
	>>> zip(*s)			
	[(1, 2, 3), ('a', 'b', 'c')]

zip(a, b)è¿›è¡Œå‹ç¼©ï¼Œ zip(*s)åˆ™æ˜¯è§£å‹

# 14. Grouping adjacent list items using zip

	>>> a = [1, 2, 3, 4, 5, 6]

	>>> # Using iterators
	>>> group_adjacent = lambda a, k: zip(*([iter(a)] * k))
	>>> group_adjacent(a, 3)
	[(1, 2, 3), (4, 5, 6)]
	>>> group_adjacent(a, 2)
	[(1, 2), (3, 4), (5, 6)]
	>>> group_adjacent(a, 1)
	[(1,), (2,), (3,), (4,), (5,), (6,)]

	>>> # Using slices
	>>> from itertools import islice
	>>> group_adjacent = lambda a, k: zip(*(islice(a, i, None, k) for i in range(k)))
	>>> group_adjacent(a, 3)
	[(1, 2, 3), (4, 5, 6)]
	>>> group_adjacent(a, 2)
	[(1, 2), (3, 4), (5, 6)]
	>>> group_adjacent(a, 1)
	[(1,), (2,), (3,), (4,), (5,), (6,)]


å…³äºzipå¯å‚è€ƒ:[Pythoné›¶ç¢çŸ¥è¯†(2):å¼ºå¤§çš„zip](http://www.cnblogs.com/beginman/archive/2013/03/14/2959447.html)

## (1).è¿­ä»£å™¨
å†…ç½®å‡½æ•°`iter()`ä½¿ç”¨å¯è¿­ä»£å¯¹è±¡(iterable object)ä½œä¸ºå‚æ•°ï¼Œè¿”å›ä¸€ä¸ªiteratorå¯¹è±¡

	>>> x = iter([1, 2, 3])
	>>> x
	<listiterator object at 0x1004ca850>
	>>> x.next()
	1
	>>> x.next()
	2
	>>> x.next()
	3
	>>> x.next()
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	StopIteration

æ¯æ¬¡è°ƒç”¨`next()`è¿”å›ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå¦‚æœæ²¡æœ‰åˆ™è§¦å‘StopIterationå¼‚å¸¸ï¼Œä¸‹é¢ç”¨ç±»æ¨¡ä»¿`xrang()`ï¼š

	class yrange:
	    def __init__(self, n):
	        self.i = 0
	        self.n = n

	    def __iter__(self):
	        return self

	    def next(self):
	        if self.i < self.n:
	            i = self.i
	            self.i += 1
	            return i
	        else:
	            raise StopIteration()

`__iter__`æ–¹æ³•ä½¿å¯¹è±¡å¯è¿­ä»£ï¼Œå°±æ˜¯é€šè¿‡è°ƒç”¨`iter`æ–¹æ³•ï¼Œè¿”å›ä¸€ä¸ªå¯è¿­ä»£å¯¹è±¡ï¼Œæ­¤å¯¹è±¡åº”è¯¥æœ‰`next`æ–¹æ³•

	>>> y = yrange(3)
	>>> y.next()
	0
	>>> y.next()
	1
	>>> y.next()
	2
	>>> y.next()
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	  File "<stdin>", line 14, in next
	StopIteration

ä¹Ÿå¯ä»¥ç›´æ¥ç”¨listç­‰å†…ç½®å‡½æ•°:

	>>> list(yrange(5))
	[0, 1, 2, 3, 4]
	>>> sum(yrange(5))
	10

åœ¨ä¸Šè¿°æƒ…å†µä¸‹ï¼Œæ— è®ºæ˜¯å¯è¿­ä»£å’Œè¿­ä»£å™¨æ˜¯åŒä¸€ä¸ªå¯¹è±¡ã€‚æ³¨æ„`__iter__`ä¸å¿…æ¯æ¬¡éƒ½è¿”å›`self`, å¦‚ä¸‹ï¼š

	class zrange:
	    def __init__(self, n):
	        self.n = n

	    def __iter__(self):
	        return zrange_iter(self.n)

	class zrange_iter:
	    def __init__(self, n):
	        self.i = 0
	        self.n = n

	    def __iter__(self):
	        # Iterators are iterables too.
	        # Adding this functions to make them so.
	        return self

	    def next(self):
	        if self.i < self.n:
	            i = self.i
	            self.i += 1
	            return i
	        else:
	            raise StopIteration()

å¦‚æœå¯è¿­ä»£å’Œè¿­ä»£å™¨æ˜¯åŒä¸€ä¸ªå¯¹è±¡ï¼Œä»–ä»¬è¢«æ¶ˆè€—åœ¨å•æ¬¡è¿­ä»£ï¼š

	>>> y = yrange(5)
	>>> list(y)
	[0, 1, 2, 3, 4]
	>>> list(y)
	[]
	>>> z = zrange(5)
	>>> list(z)
	[0, 1, 2, 3, 4]
	>>> list(z)
	[0, 1, 2, 3, 4]


## (2). ç”Ÿæˆå™¨
ç”Ÿæˆå™¨ç®€åŒ–äº†åˆ›å»ºè¿­ä»£å™¨:

	def yrange(n):
	    i = 0
	    while i < n:
	        yield i
	        i += 1

æ¯æ¬¡`yield`è¯­å¥ç”Ÿæˆä¸€ä¸ªæ–°å€¼ï¼š

	>>> y = yrange(3)
	>>> y
	<generator object yrange at 0x401f30>
	>>> y.next()
	0
	>>> y.next()
	1
	>>> y.next()
	2
	>>> y.next()
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	StopIteration

æ‰€ä»¥**ç”Ÿæˆå™¨ä¹Ÿæ˜¯è¿­ä»£å™¨**

	>>> def foo():
	...     print "begin"
	...     for i in range(3):
	...         print "before yield", i
	...         yield i
	...         print "after yield", i
	...     print "end"
	...
	>>> f = foo()
	>>> f.next()
	begin
	before yield 0
	0
	>>> f.next()
	after yield 0
	before yield 1
	1
	>>> f.next()
	after yield 1
	before yield 2
	2
	>>> f.next()
	after yield 2
	end
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	StopIteration
	>>>

ä¸‹é¢ä¸€ä¸ªç®—æ³•ï¼Œä½¿ç”¨ç”Ÿæˆå™¨çš„æ–¹å¼è®¡ç®—è¿ç»­nä¸ªå…ƒç´ (0~n, nå¯æ— ç©·å¤§)çš„å¹³æ–¹ï¼š

	def integers():
	    i = 1
	    while 1:
	        yield i
	        i += 1


	def squares():
	    for i in integers():
	        yield i * i


	def take(n, seq):
	    result = []
	    seq = iter(seq)
	    try:
	        for i in range(n):
	            result.append(seq.next())
	    except StopIteration:
	        pass
	    return result


	print take(5, squares()) # prints [1, 4, 9, 16, 25]


## (3).ç”Ÿæˆå™¨è¡¨è¾¾å¼
ç”Ÿæˆå™¨è¡¨è¾¾å¼çœ‹èµ·æ¥åƒlistçš„å«ä¹‰ï¼Œä½†è¿”å›çš„æ˜¯ä¸€ä¸ªå¤‡ç”¨çš„ç”Ÿæˆå™¨è€Œéä¸€ä¸ªåˆ—è¡¨.ç‰¹ä¹ˆè¿™å¥è¯"Generator Expressions are generator version of list comprehensions. They look like list comprehensions, but returns a generator back instead of a list."æˆ‘ä¹Ÿä¸å¥½ç†è§£ã€‚ã€‚ã€‚ã€‚

![](http://beginman.qiniudn.com/funs.png)

	>>> a = (x for x in range(10))
	>>> a
	<generator object <genexpr> at 0x103279aa0>
	>>> sum(a)
	45

	>>> a = (x for x in range(10))
	>>> a.next()
	0
	>>> a.next()
	1
	>>> a.next()
	2
	>>> sum(a)		# æ³¨æ„ç¼©å‡å•Š
	42

## (4).xrange vs range

- `range`: range([start,] stop[, step])ï¼Œæ ¹æ®startä¸stopæŒ‡å®šçš„èŒƒå›´ä»¥åŠstepè®¾å®šçš„æ­¥é•¿ï¼Œç”Ÿæˆä¸€ä¸ªåºåˆ—ã€‚
- `xrange`: ç”¨æ³•ä¸rangeå®Œå…¨ç›¸åŒï¼Œæ‰€ä¸åŒçš„æ˜¯ç”Ÿæˆçš„ä¸æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œè€Œæ˜¯ä¸€ä¸ªç”Ÿæˆå™¨ã€‚

	>>> xrange(1,5)
	xrange(1, 5)
	>>> list(xrange(1,5))
	[1, 2, 3, 4]


**è¦ç”Ÿæˆå¾ˆå¤§çš„æ•°å­—åºåˆ—çš„æ—¶å€™ï¼Œç”¨xrangeä¼šæ¯”rangeæ€§èƒ½ä¼˜å¾ˆå¤šï¼Œå› ä¸ºä¸éœ€è¦ä¸€ä¸Šæ¥å°±å¼€è¾Ÿä¸€å—å¾ˆå¤§çš„å†…å­˜ç©ºé—´ï¼Œè¿™ä¸¤ä¸ªåŸºæœ¬ä¸Šéƒ½æ˜¯åœ¨å¾ªç¯çš„æ—¶å€™ç”¨**

## (5). itertools.islice
å‡½æ•°åŸå‹:

	itertools.islice(iterable, start, stop[, step])

è¿”å›çš„è¿­ä»£å™¨æ˜¯è¿”å›äº†è¾“å…¥è¿­ä»£å™¨æ ¹æ®ç´¢å¼•æ¥é€‰å–çš„é¡¹,ç”Ÿæˆé¡¹çš„æ–¹å¼ç±»ä¼¼äºåˆ‡ç‰‡è¿”å›å€¼,ä¸åˆ‡ç‰‡ä¸åŒï¼Œè´Ÿå€¼ä¸ä¼šç”¨äºä»»ä½•startï¼Œstopå’Œstepï¼Œ å¦‚æœçœç•¥äº†startï¼Œè¿­ä»£å°†ä»0å¼€å§‹ï¼Œå¦‚æœçœç•¥äº†stepï¼Œæ­¥å¹…å°†é‡‡ç”¨1.

	from itertools import *

	print 'Stop at 5:'
	for i in islice(count(), 5):
	    print i,					# 0,1,2,3,4

	print 'Start at 5, Stop at 10:'
	for i in islice(count(), 5, 10):
	    print i,					# 5,6,7,8,9

	print 'By tens to 100:'
	for i in islice(count(), 0, 100, 10):
	    print i,					# 0,10,20,30,40,50,60,70,80,90

å†ä¸Šä¸€ä¸ªä¾‹å­ä¸­ï¼Œç”¨äº†é«˜é˜¶å‡½æ•°`islice()`å®ç°ï¼š

	>>> group_adjacent = lambda a, k: zip(*(islice(a, i, None, k) for i in range(k)))
	>>> group_adjacent(a, 3)
	[(1, 2, 3), (4, 5, 6)]

ä¹ä¸€çœ‹ä¼šæœ‰ç‚¹å“äººï¼Œæˆ‘ä»¬æ‹†åˆ†æ¥çœ‹ï¼š

	>>> s = (islice(range(10), i, None, 3) for i in range(3))			# é€šè¿‡forå¾ªç¯ç”¨isliceåˆ›å»º3ä¸ªè¿­ä»£å™¨ï¼Œç»„æˆäº†ç”Ÿæˆå™¨
	>>> for i in s:
	...     print i, list(i)
	... 
	<itertools.islice object at 0x10329b368> [0, 3, 6, 9]			# islice(range(10), 0, None, 3) --ä»0ç´¢å¼•å¼€å§‹æ­¥é•¿ä¸º3-> [0, 3, 6, 9]
	<itertools.islice object at 0x10329b260> [1, 4, 7]				# islice(range(10), 1, None, 3) -- ä»1ç´¢å¼•å¼€å§‹æ­¥é•¿ä¸º3->[1,4,7]
	<itertools.islice object at 0x10329b368> [2, 5, 8]				# islice(range(10), 2, None, 3) -- ä»2ç´¢å¼•å¼€å§‹æ­¥é•¿ä¸º3->[2,5,8]

é‚£ä¹ˆ`zip(*s)`è§£å‹, ç”±äºæœ€çŸ­å…ƒç´ ä¸ªæ•°ä¸º3ä¸ªï¼Œåˆ™å…ƒç´ 9ä¼šè¢«è¿‡æ»¤æ‰ï¼š

	>>> s = (islice(range(10), i, None, 3) for i in range(3))
	>>> zip(*s)
	[(0, 1, 2), (3, 4, 5), (6, 7, 8)]

# 15. Sliding windows (n-grams) using zip and iterators

	>>> from itertools import islice
	>>> def n_grams(a, n):
	...     z = (islice(a, i, None) for i in range(n))		# è¿™é‡Œæ­¥é•¿ä¸º1
	...     return zip(*z)
	...
	>>> a = [1, 2, 3, 4, 5, 6]
	>>> n_grams(a, 3)
	[(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]
	>>> n_grams(a, 2)
	[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]
	>>> n_grams(a, 4)
	[(1, 2, 3, 4), (2, 3, 4, 5), (3, 4, 5, 6)]

# 16. Inverting a dictionary using zip

	>>> m = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
	>>> m.items()
	[('a', 1), ('c', 3), ('b', 2), ('d', 4)]
	>>> zip(m.values(), m.keys())
	[(1, 'a'), (3, 'c'), (2, 'b'), (4, 'd')]
	>>> mi = dict(zip(m.values(), m.keys()))
	>>> mi
	{1: 'a', 2: 'b', 3: 'c', 4: 'd'}

# 17. Flattening lists:

è¿™é‡Œå¼€å§‹å¹³é“ºäº†ï¼Œå…±æœ‰3ç§æ–¹å¼ï¼š`itertools.chain.from_iterable`, `sum`, å’Œåˆ—è¡¨æ¨å¯¼

	>>> a = [[1, 2], [3, 4], [5, 6]]
	>>> list(itertools.chain.from_iterable(a))
	[1, 2, 3, 4, 5, 6]

	>>> sum(a, [])
	[1, 2, 3, 4, 5, 6]

	>>> [x for l in a for x in l]
	[1, 2, 3, 4, 5, 6]

	>>> a = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
	>>> [x for l1 in a for l2 in l1 for x in l2]
	[1, 2, 3, 4, 5, 6, 7, 8]

	>>> a = [1, 2, [3, 4], [[5, 6], [7, 8]]]
	>>> flatten = lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x]
	>>> flatten(a)
	[1, 2, 3, 4, 5, 6, 7, 8]

# 18. Generator expressions

	>>> g = (x ** 2 for x in xrange(10))
	>>> next(g)
	0
	>>> next(g)
	1
	>>> next(g)
	4
	>>> next(g)
	9
	>>> sum(x ** 3 for x in xrange(10))
	2025
	>>> sum(x ** 3 for x in xrange(10) if x % 3 == 1)
	408

# 19. Dictionary comprehensions

	>>> m = {x: x ** 2 for x in range(5)}
	>>> m
	{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

	>>> m = {x: 'A' + str(x) for x in range(10)}
	>>> m
	{0: 'A0', 1: 'A1', 2: 'A2', 3: 'A3', 4: 'A4', 5: 'A5', 6: 'A6', 7: 'A7', 8: 'A8', 9: 'A9'}

# 20. Inverting a dictionary using a dictionary comprehension

	>>> m = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
	>>> m
	{'d': 4, 'a': 1, 'b': 2, 'c': 3}
	>>> {v: k for k, v in m.items()}
	{1: 'a', 2: 'b', 3: 'c', 4: 'd'}


# 21. Named tuples (collections.namedtuple)

	>>> Point = collections.namedtuple('Point', ['x', 'y'])
	>>> p = Point(x=1.0, y=2.0)
	>>> p
	Point(x=1.0, y=2.0)
	>>> p.x
	1.0
	>>> p.y
	2.0

Pythonæ‹¥æœ‰ä¸€äº›å†…ç½®çš„æ•°æ®ç±»å‹ï¼Œæ¯”å¦‚str, int, list, tuple, dictç­‰ï¼Œ `collections`æ¨¡å—åœ¨è¿™äº›å†…ç½®æ•°æ®ç±»å‹çš„åŸºç¡€ä¸Šï¼Œæä¾›äº†å‡ ä¸ªé¢å¤–çš„æ•°æ®ç±»å‹ï¼š

- `namedtuple()`: ç”Ÿæˆå¯ä»¥ä½¿ç”¨åå­—æ¥è®¿é—®å…ƒç´ å†…å®¹çš„tupleå­ç±»
- `deque`: åŒç«¯é˜Ÿåˆ—ï¼Œå¯ä»¥å¿«é€Ÿçš„ä»å¦å¤–ä¸€ä¾§è¿½åŠ å’Œæ¨å‡ºå¯¹è±¡
- `Counter`: è®¡æ•°å™¨ï¼Œä¸»è¦ç”¨æ¥è®¡æ•°
- `OrderedDict`: æœ‰åºå­—å…¸
- `defaultdict`: å¸¦æœ‰é»˜è®¤å€¼çš„å­—å…¸

å¯å‚è€ƒ[ä¸å¯ä¸çŸ¥çš„Pythonæ¨¡å—: collections](http://www.zlovezl.cn/articles/collections-in-python/)

# 22. Inheriting from named tuples:

	>>> class Point(collections.namedtuple('PointBase', ['x', 'y'])):
	...     __slots__ = ()
	...     def __add__(self, other):
	...             return Point(x=self.x + other.x, y=self.y + other.y)
	...
	>>> p = Point(x=1.0, y=2.0)
	>>> q = Point(x=2.0, y=3.0)
	>>> p + q
	Point(x=3.0, y=5.0)

# 23. Sets and set operations

	>>> A = {1, 2, 3, 3}
	>>> A
	set([1, 2, 3])
	>>> B = {3, 4, 5, 6, 7}
	>>> B
	set([3, 4, 5, 6, 7])
	>>> A | B
	set([1, 2, 3, 4, 5, 6, 7])
	>>> A & B
	set([3])
	>>> A - B
	set([1, 2])
	>>> B - A
	set([4, 5, 6, 7])
	>>> A ^ B
	set([1, 2, 4, 5, 6, 7])
	>>> (A ^ B) == ((A - B) | (B - A))
	True

# 24. Multisets and multiset operations (collections.Counter)

	>>> A = collections.Counter([1, 2, 2])
	>>> B = collections.Counter([2, 2, 3])
	>>> A
	Counter({2: 2, 1: 1})
	>>> B
	Counter({2: 2, 3: 1})
	>>> A | B
	Counter({2: 2, 1: 1, 3: 1})
	>>> A & B
	Counter({2: 2})
	>>> A + B
	Counter({2: 4, 1: 1, 3: 1})
	>>> A - B
	Counter({1: 1})
	>>> B - A
	Counter({3: 1})

# 25. Most common elements in an iterable (collections.Counte

	>>> A = collections.Counter([1, 1, 2, 2, 3, 3, 3, 3, 4, 5, 6, 7])
	>>> A
	Counter({3: 4, 1: 2, 2: 2, 4: 1, 5: 1, 6: 1, 7: 1})
	>>> A.most_common(1)
	[(3, 4)]
	>>> A.most_common(3)
	[(3, 4), (1, 2), (2, 2)]

# 26. Double-ended queue (collections.deque)

	>>> Q = collections.deque()
	>>> Q.append(1)
	>>> Q.appendleft(2)
	>>> Q.extend([3, 4])
	>>> Q.extendleft([5, 6])
	>>> Q
	deque([6, 5, 2, 1, 3, 4])
	>>> Q.pop()
	4
	>>> Q.popleft()
	6
	>>> Q
	deque([5, 2, 1, 3])
	>>> Q.rotate(3)
	>>> Q
	deque([2, 1, 3, 5])
	>>> Q.rotate(-3)
	>>> Q
	deque([5, 2, 1, 3])

# 27. Double-ended queue with maximum length (collections.deque)

	>>> last_three = collections.deque(maxlen=3)
	>>> for i in xrange(10):
	...     last_three.append(i)
	...     print ', '.join(str(x) for x in last_three)
	...
	0
	0, 1
	0, 1, 2
	1, 2, 3
	2, 3, 4
	3, 4, 5
	4, 5, 6
	5, 6, 7
	6, 7, 8
	7, 8, 9

# 28. Ordered dictionaries (collections.OrderedDict)

	>>> m = dict((str(x), x) for x in range(10))
	>>> print ', '.join(m.keys())
	1, 0, 3, 2, 5, 4, 7, 6, 9, 8
	>>> m = collections.OrderedDict((str(x), x) for x in range(10))
	>>> print ', '.join(m.keys())
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9
	>>> m = collections.OrderedDict((str(x), x) for x in range(10, 0, -1))
	>>> print ', '.join(m.keys())
	10, 9, 8, 7, 6, 5, 4, 3, 2, 1

# 29. Default dictionaries (collections.defaultdict)

	>>> m = dict()
	>>> m['a']
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	KeyError: 'a'
	>>>
	>>> m = collections.defaultdict(int)
	>>> m['a']
	0
	>>> m['b']
	0
	>>> m = collections.defaultdict(str)
	>>> m['a']
	''
	>>> m['b'] += 'a'
	>>> m['b']
	'a'
	>>> m = collections.defaultdict(lambda: '[default value]')
	>>> m['a']
	'[default value]'
	>>> m['b']
	'[default value]'

# 30. Using default dictionaries to represent simple trees

	>>> import json
	>>> tree = lambda: collections.defaultdict(tree)
	>>> root = tree()
	>>> root['menu']['id'] = 'file'
	>>> root['menu']['value'] = 'File'
	>>> root['menu']['menuitems']['new']['value'] = 'New'
	>>> root['menu']['menuitems']['new']['onclick'] = 'new();'
	>>> root['menu']['menuitems']['open']['value'] = 'Open'
	>>> root['menu']['menuitems']['open']['onclick'] = 'open();'
	>>> root['menu']['menuitems']['close']['value'] = 'Close'
	>>> root['menu']['menuitems']['close']['onclick'] = 'close();'
	>>> print json.dumps(root, sort_keys=True, indent=4, separators=(',', ': '))
	{
	    "menu": {
	        "id": "file",
	        "menuitems": {
	            "close": {
	                "onclick": "close();",
	                "value": "Close"
	            },
	            "new": {
	                "onclick": "new();",
	                "value": "New"
	            },
	            "open": {
	                "onclick": "open();",
	                "value": "Open"
	            }
	        },
	        "value": "File"
	    }
	}

# 31. Mapping objects to unique counting numbers (collections.defaultdict)

	>>> import itertools, collections
	>>> value_to_numeric_map = collections.defaultdict(itertools.count().next)
	>>> value_to_numeric_map['a']
	0
	>>> value_to_numeric_map['b']
	1
	>>> value_to_numeric_map['c']
	2
	>>> value_to_numeric_map['a']
	0
	>>> value_to_numeric_map['b']
	1
	>>>value
	defaultdict(<method-wrapper 'next' of itertools.count object at 0x1094cdb00>,
            {'a': 0, 'b': 1, 'c': 2, 'd': 3})

 ä¸Šé¢è¿™å‡ éƒ¨åˆ†ç”¨çš„äº†`collections`æ¨¡å—ï¼Œå…³äºæ­¤æ¨¡å—å‚è€ƒè¿™é‡Œå§ï¼š[Python collectionsæ¨¡å—](http://beginman.cn/python/2015/09/07/collections/)


# 32. Largest and smallest elements (heapq.nlargest and heapq.nsmallest)

	>>>import random, heapq
	>>>a = [random.randint(0, 100) for __ in xrange(100)]
	>>> heapq.nsmallest(5, a)		# 5ä¸ªæœ€å°å…ƒç´ 
	[0, 2, 4, 6, 8]
	>>> heapq.nlargest(5, a)		# 5ä¸ªæœ€å¤§å…ƒç´ 
	[100, 100, 98, 96, 95]

# 33. Cartesian products (itertools.product)
	
	>>> for p in itertools.product([1, 2, 3], [4, 5]):
	(1, 4)
	(1, 5)
	(2, 4)
	(2, 5)
	(3, 4)
	(3, 5)
	>>> for p in itertools.product([0, 1], repeat=4):
	...     print ''.join(str(x) for x in p)
	...
	0000
	0001
	0010
	0011
	0100
	0101
	0110
	0111
	1000
	1001
	1010
	1011
	1100
	1101
	1110
	1111

# 34.Combinations and combinations with replacement (itertools.combinations and itertools.combinations_with_replacement)

	In [48]: for i in itertools.combinations([1,2,3,4,5], 3):
	   ....:     print i
	   ....:     
	(1, 2, 3)
	(1, 2, 4)
	(1, 2, 5)
	(1, 3, 4)
	(1, 3, 5)
	(1, 4, 5)
	(2, 3, 4)
	(2, 3, 5)
	(2, 4, 5)
	(3, 4, 5)


	In [51]: for c in itertools.combinations_with_replacement([1,2,3,4,5], 3):
    print c
	   ....:     
	(1, 1, 1)
	(1, 1, 2)
	(1, 1, 3)
	(1, 1, 4)
	(1, 1, 5)
	(1, 2, 2)
	(1, 2, 3)
	(1, 2, 4)
	(1, 2, 5)
	(1, 3, 3)
	(1, 3, 4)
	(1, 3, 5)
	(1, 4, 4)
	(1, 4, 5)
	(1, 5, 5)
	(2, 2, 2)
	(2, 2, 3)
	(2, 2, 4)
	(2, 2, 5)
	(2, 3, 3)
	(2, 3, 4)
	(2, 3, 5)
	(2, 4, 4)
	(2, 4, 5)
	(2, 5, 5)
	(3, 3, 3)
	(3, 3, 4)
	(3, 3, 5)
	(3, 4, 4)
	(3, 4, 5)
	(3, 5, 5)
	(4, 4, 4)
	(4, 4, 5)
	(4, 5, 5)
	(5, 5, 5)


# 35. Permutations (itertools.permutations)

	In [52]: for i in itertools.permutations([1,2,3,4]):
	   ....:     print i
	   ....:     
	(1, 2, 3, 4)
	(1, 2, 4, 3)
	(1, 3, 2, 4)
	(1, 3, 4, 2)
	(1, 4, 2, 3)
	(1, 4, 3, 2)
	(2, 1, 3, 4)
	(2, 1, 4, 3)
	(2, 3, 1, 4)
	(2, 3, 4, 1)
	(2, 4, 1, 3)
	(2, 4, 3, 1)
	(3, 1, 2, 4)
	(3, 1, 4, 2)
	(3, 2, 1, 4)
	(3, 2, 4, 1)
	(3, 4, 1, 2)
	(3, 4, 2, 1)
	(4, 1, 2, 3)
	(4, 1, 3, 2)
	(4, 2, 1, 3)
	(4, 2, 3, 1)
	(4, 3, 1, 2)
	(4, 3, 2, 1)

# 36. Chaining iterables (itertools.chain)

	>>> a = [1, 2, 3, 4]
	>>> for p in itertools.chain(itertools.combinations(a, 2), itertools.combinations(a, 3)):
	...     print p
	...
	(1, 2)
	(1, 3)
	(1, 4)
	(2, 3)
	(2, 4)
	(3, 4)
	(1, 2, 3)
	(1, 2, 4)
	(1, 3, 4)
	(2, 3, 4)
	>>> for subset in itertools.chain.from_iterable(itertools.combinations(a, n) for n in range(len(a) + 1))
	...     print subset
	...
	()
	(1,)
	(2,)
	(3,)
	(4,)
	(1, 2)
	(1, 3)
	(1, 4)
	(2, 3)
	(2, 4)
	(3, 4)
	(1, 2, 3)
	(1, 2, 4)
	(1, 3, 4)
	(2, 3, 4)
	(1, 2, 3, 4)

# 37. Grouping rows by a given key (itertools.groupby)

	>>> from operator import itemgetter
	>>> import itertools
	>>> with open('contactlenses.csv', 'r') as infile:
	...     data = [line.strip().split(',') for line in infile]
	...
	>>> data = data[1:]
	>>> def print_data(rows):
	...     print '\n'.join('\t'.join('{: <16}'.format(s) for s in row) for row in rows)
	...

	>>> print_data(data)
	young               myope                   no                      reduced                 none
	young               myope                   no                      normal                  soft
	young               myope                   yes                     reduced                 none
	young               myope                   yes                     normal                  hard
	young               hypermetrope            no                      reduced                 none
	young               hypermetrope            no                      normal                  soft
	young               hypermetrope            yes                     reduced                 none
	young               hypermetrope            yes                     normal                  hard
	pre-presbyopic      myope                   no                      reduced                 none
	pre-presbyopic      myope                   no                      normal                  soft
	pre-presbyopic      myope                   yes                     reduced                 none
	pre-presbyopic      myope                   yes                     normal                  hard
	pre-presbyopic      hypermetrope            no                      reduced                 none
	pre-presbyopic      hypermetrope            no                      normal                  soft
	pre-presbyopic      hypermetrope            yes                     reduced                 none
	pre-presbyopic      hypermetrope            yes                     normal                  none
	presbyopic          myope                   no                      reduced                 none
	presbyopic          myope                   no                      normal                  none
	presbyopic          myope                   yes                     reduced                 none
	presbyopic          myope                   yes                     normal                  hard
	presbyopic          hypermetrope            no                      reduced                 none
	presbyopic          hypermetrope            no                      normal                  soft
	presbyopic          hypermetrope            yes                     reduced                 none
	presbyopic          hypermetrope            yes                     normal                  none

	>>> data.sort(key=itemgetter(-1))
	>>> for value, group in itertools.groupby(data, lambda r: r[-1]):
	...     print '-----------'
	...     print 'Group: ' + value
	...     print_data(group)
	...
	-----------
	Group: hard
	young               myope                   yes                     normal                  hard
	young               hypermetrope            yes                     normal                  hard
	pre-presbyopic      myope                   yes                     normal                  hard
	presbyopic          myope                   yes                     normal                  hard
	-----------
	Group: none
	young               myope                   no                      reduced                 none
	young               myope                   yes                     reduced                 none
	young               hypermetrope            no                      reduced                 none
	young               hypermetrope            yes                     reduced                 none
	pre-presbyopic      myope                   no                      reduced                 none
	pre-presbyopic      myope                   yes                     reduced                 none
	pre-presbyopic      hypermetrope            no                      reduced                 none
	pre-presbyopic      hypermetrope            yes                     reduced                 none
	pre-presbyopic      hypermetrope            yes                     normal                  none
	presbyopic          myope                   no                      reduced                 none
	presbyopic          myope                   no                      normal                  none
	presbyopic          myope                   yes                     reduced                 none
	presbyopic          hypermetrope            no                      reduced                 none
	presbyopic          hypermetrope            yes                     reduced                 none
	presbyopic          hypermetrope            yes                     normal                  none
	-----------
	Group: soft
	young               myope                   no                      normal                  soft
	young               hypermetrope            no                      normal                  soft
	pre-presbyopic      myope                   no                      normal                  soft
	pre-presbyopic      hypermetrope            no                      normal                  soft
	presbyopic          hypermetrope            no                      normal                  soft

è¿™å‡ ä¸ªéƒ½æ˜¯`itertools`æ¨¡å—çš„å†…å®¹ï¼Œå¯å‚è€ƒ[PYTHON-è¿›é˜¶-ITERTOOLSæ¨¡å—å°ç»“](http://www.wklken.me/posts/2013/08/20/python-extra-itertools.html#itertoolsisliceiterable-stop)

